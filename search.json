[{"title":"常用优化器总结（一）","path":"/2023/09/29/optimizer1/","content":"什么是优化器优化器（Optimizer），或者称优化算法，是机器学习或深度学习中用来最小化损失函数的算法。损失函数用来衡量模型预测值和实际值之间的差异，优化器则可以通过一定的策略自动调整模型中的参数值，以使得损失函数的值尽可能的小。 符号约定以下是本文中使用到的一些符号： $\\theta$: 模型的参数 $J(\\theta)$: 损失函数 $ abla_\\theta J(\\theta)$：参数$\\theta$的梯度 $\\eta$：学习率 $x^{(i)}$：第$i$个样本的特征 $y^{(i)}$：第$i$个样本的标签 梯度下降试想我们在山顶上放置一个小球让其向下滚落，则小球每次都会从当前位置最陡的方向向下滚动，最终到达山底。当前位置最陡的方向就是梯度的方向。可以将损失函数也类比为一座山，最开始的时候，我们处在山坡或者山顶，然后我们计算出当前位置的梯度$ abla_\\theta J(\\theta)$，然后根据梯度$ abla_\\theta J(\\theta)$更新参数，这相当于小球在最陡的方向滚动了一步，然后重复梯度更新的过程，直至达到损失函数的最小点。 根据计算梯度所使用的样本数量，可以将梯度下降（Gradient Decent）分为批量梯度下降（Batch Gradient Decent，BGD）、随机梯度下降（Stochastic Gradient Descent，SGD）和小批量梯度下降（Mini-batch Gradient Descent，MBGD）。 批量梯度下降批量梯度下降（Batch Gradient Decent，BGD）每次使用全部的样本计算梯度并更新参数$$\\theta &#x3D; \\theta - \\eta abla_\\theta J(\\theta)$$ 优点 批量梯度下降可以保证收敛到凸函数的最小值，或者非凸函数的极小值点； 缺点 批量梯度下降每次根据全量数据计算梯度，这会导致计算过程非常缓慢，而且如果内存（显存）不足，而数据量又很大时，可能无法一次性加载全部样本计算梯度； 极值和最值 随机梯度下降随机梯度下降（Stochastic Gradient Descent，SGD）每次只使用一个样本$&lt;x^{(i)}, y^{(i)}&gt;$来计算梯度并更新参数$$\\theta &#x3D; \\theta - \\eta abla_\\theta J(\\theta;x^{(i)};y^{(i)})$$ 优点 每次只使用一个样本更新参数，不会有数据无法加载到内存中的情况； 对于非凸函数，批量梯度下降会收敛到极值点，而由于随机梯度下降每次只使用一个样本计算梯度，相当于只考虑了局部数据的特征，这会使得损失函数值的波动比较剧烈，可能会跳出极小值点，从而收敛到最小值点； 缺点 损失函数值波动剧烈，会增长收敛时间； 损失函数值的波动可能会跳出极小值点，收敛到最小值点，也可能导致无法收敛； 小批量梯度下降小批量梯度下降（Mini-batch Gradient Descent，MBGD）是BGD和SGD的一个折中，它每次使用$m$个样本计算梯度并更新参数$$\\theta &#x3D; \\theta - \\eta abla_\\theta J(\\theta;x^{(i:i+m)};y^{(i:i+m)})$$其中，$m$是一个batch中样本的个数。假设$n$为样本总量，当$m$等于1时，MBGD变为SGD；当$m$等于$n$时，MBGD变为BGD。 优点 相比于批量梯度下降，计算速度更快； 相比于随机梯度下降，收敛过程更加稳定； 缺点 选择合适的学习率比较困难。太小的学习率会导致收敛缓慢，太大的学习率会导致无法收敛到最小值，而是在最小值附近波动，甚至无法收敛； 容易被困在鞍点； 所有的参数使用相同的学习率，对于不同数据集的适应性较差； 注意：上述的BGD和SGD很少被使用，MBGD使用较多。在实际使用中，SGD一般指的是MBGD。在下文中，如果没用明确指出，默认使用SGD表示MBGD。 MomentumMomentum的目的是降低SGD在优化过程中的波动，加快SGD的收敛速度。具体来说，Momentum将梯度更新看作是一个运动的过程，在其中引入了动量的概念，梯度更新的方向就是动量的方向。 Momentum每次在进行梯度更新时，不仅考虑当前梯度的方向，还会考虑之前梯度的方向，这样相当于在参数更新时增加一个惯性，能够在一定程度上减少梯度更新的震荡，使得参数更新的方向更加的稳定。 如上图所示，左边原始的SGD在更新过程中梯度的方向波动较大，而由于Momentum由于考虑了之前梯度的方向，所以波动会相对较小。 举个例子，假设之前梯度的方向是向右上的，而当前梯度的方向是向右下的。如果没有Momentum，则梯度会完全向右下更新。在Momentum中，由于考虑了之前向上的梯度，所以之前向上的梯度和当前向下的梯度会做一个抵消，削弱了向下更新的程度，梯度会更专注于向着最小值方向（向右）前进，从而使得更新过程更加平滑和稳定，收敛速度也会更快。 Momentum可以被形式化为以下公式$$\\begin{equation}\\begin{split}v_t &#x3D; \\beta v_{t-1} + (1 - \\beta) abla_\\theta J(\\theta) \\\\theta &#x3D; \\theta - \\eta v_t\\end{split}\\end{equation}$$其中 $v_t$是当前时刻的动量（梯度），$v_{t-1}$是前一时刻的动量，$v_0$初始化为0； $\\beta$是Momentum的超参数，取值范围为[0, 1]，常见值为0.9； $\\eta$为学习率； 优点： 可以减少梯度更新过程中的震荡，并加速收敛；","tags":["深度学习","优化器"]},{"title":"国庆九日记","path":"/2023/09/28/nations-day/","content":"国庆节是下半年最长的节日，今年因为国庆节和中秋节重叠，所以一共有8天的假期。当然，假期结束后也会有2天的调休。想用这篇博客记录下我在这个假期里的生活。 2023&#x2F;09&#x2F;28今天是我的假期的第一天。实际上，法定假期从明天才开始，因为明天是中秋节，所以我请了一天假提前走了。国庆节景区人会非常的多，去景区也没有很好的体验，再加上我最近非常累，所以选择了回家休息。因为头天晚上睡不着，而且早上也起不来，所以一直拖到火车开前1个小时才出发，还好路上比较顺利，赶上了火车。可能是因为我提前走一天的原因，地铁和火车站的人流量是正常的水平，没有人特别多的感觉。在火车上，由于有人外放加上小孩吵闹的缘故，我基本上没有睡觉。到家后觉得挺累的，毕竟坐了一天，也没怎么吃饭。刚把饭吃了，打算今天早点睡。 给自己的假期定一个基调： 早睡早起 少玩手机 增强自律","tags":["生活"]},{"title":"使用Github Actions实现Hexo博客的自动部署","path":"/2023/08/19/hexo-with-actions/","content":"什么是Github Actions简单来说，Actions是一个工作流（Workflow），可以根据设定的触发条件，执行一连串预设的操作，从而实现工作的自动执行。具体可以参考这篇文章。在写博客场景下，我们希望有这样的一个Actions，当我们将写好的博客推到Github时，Actions能帮我们自动执行hexo g、hexo d这些操作。这样我们在写完博客后，push到Github上就行了，其余的博客编译，部署都是自动的，大大降低了复杂度。 为了实现上面的功能，我们首先需要创建两个仓库：源码库和公开库。 两个仓库 源码库可以使用 hexo init blog来创建一个名为blog的源码库，源码库用来存放博客源文件（markdown文件）。需要将本地创建的源码库push到Github上。推到Github上后，源码库可以设为私有库。 公开库如果我们在源码库里执行hexo g会产生一个public文件夹，这个文件夹包含了编译后的静态网页文件，也是公开库的内容，在Github上对应仓库$&#123;username&#125;.github.io。 整体的流程是：本地写博客-&gt;push到源码库-&gt;命中Actions的触发条件，自动执行编译-&gt;自动将编译得到的public文件夹内容push到公开库-&gt;完成。 SecretsSecrets可以理解为Actions工作的一个凭证，配置文件中的Secrets和在Github上设置的Secrets一致时，Actions中的相关步骤才能正常执行。在Github上创建Secrets的方法是：头像-&gt;Settings-&gt;Developer Settings-&gt;Personal Access Tokens-&gt;Tokens(classic)-&gt;Generate new token-&gt;选择workflow，如下所示 然后拷贝生成的token，打开Github上的源码库-&gt;Settings-&gt;Secrets and variables创建一个名为PERSONAL_TOKEN的Secrets，如下图 配置Actions这一步我们定义Actions在什么时候触发，触发后执行什么操作。在源码库下新建文件.github/workflows/auto-deploy.yml，例如我的内容如下： 1234567891011121314151617181920212223242526272829303132333435363738name: auto deployon: workflow_dispatch: push: # 触发的条件为push操作，如果向这个仓库push，就是执行下面的jobsjobs: build: runs-on: ubuntu-latest # 运行环境为最新版 Ubuntu name: auto deploy steps: # 1. 获取源码 - name: Checkout uses: actions/checkout@v3 # 使用 actions/checkout@v3 with: # 条件 submodules: true # Checkout private submodules(themes or something else). 当有子模块时切换分支？ # 2. 配置环境 - name: Setup Node.js 18.12.x uses: actions/setup-node@master with: node-version: &quot;18.12.x&quot; # 3. 生成静态文件 - name: Generate Public Files run: | npm i npm install hexo-cli -g hexo clean &amp;&amp; hexo generate # 4. 部署到 GitHub 仓库（可选） - name: Deploy to GitHub Pages uses: peaceiris/actions-gh-pages@v3 with: personal_token: $&#123;&#123; secrets.PERSONAL_TOKEN &#125;&#125; # 这个就是配置的secrets external_repository: $&#123;username&#125;/$&#123;username&#125;.github.io # 需要修改为自己的用户名 publish_branch: gh-pages # 推到了公开库的gh-pages分支 publish_dir: ./public commit_message: $&#123;&#123; github.event.head_commit.message &#125;&#125; user_name: &#x27;$&#123;username&#125;&#x27; # 需要修改为自己的用户名 user_email: &#x27;$&#123;username&#125;@exampe.com&#x27; # 需要修改为自己的邮箱 上面的文件定义了一个完整的Actions，最终将编译好的博客push到公开库的gh-pages分支。需要注意的是，如果公开库设定的展示分支不是gh-pages，需要修改为gh-pages。或者修改上面的配置，将publish_branch改为自己的分支。 至此，Actions就被配置好了。我们在源码库写完博客后，git add、git commit、git push到Github上就会自动部署到Github Pages，省去了搭建Hexo环境的步骤，非常方便。而且，如果我们想在别的电脑上写博客，git clone源码库到本地修改即可，也可以使用Github提供的Codespaces在浏览器里修改后执行push，多端修改也很方便。 参考 零成本！无需服务器也能搭建自己的博客网站，支持CI&#x2F;CD！ 配置Github Action实现自动发布 利用 GitHub Actions 自动部署 Hexo 博客","tags":["教程, hexo"]},{"title":"关于","path":"/about/index.html","content":"游山西村陆游莫笑农家腊酒浑，丰年留客足鸡豚。山重水复疑无路，柳暗花明又一村。箫鼓追随春社近，衣冠简朴古风存。从今若许闲乘月，拄杖无时夜叩门。诗词节选"}]